<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[tvOS入门]]></title>
      <url>%2F2018%2F05%2F05%2FtvOS%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[初次接触到tvOS，和iOS开发有很大不同，主要体现在两者的交互模式。iOS以接受屏幕点击事件进行交互，tvOS通过遥控器聚焦的方式进行交互。这样的不同给iOS开发者转tvOS开发有些不适应，这里做下在开发中遇到的问题以及解决的办法。 剧情交代进入CGTN这家公司，第一个任务就是搜索界面的键盘自定义，系统没有暴露属性来修改键盘样式，尝试使用KVC的方式来解决，但是较为困难，并且有使用私有API而被拒的风险，最终选择封装这样的一个键盘。封装键盘的过程中遇到一个核心问题——聚焦。默认情况下UIButton,UICollection,UITableView是可以自动被聚焦的，在聚焦变动的情况下，系统帮我们需在最近的控件为聚焦状态，当然也有可能找不到的情况。 UIFocusGuide12345678910111213141516171819202122232425262728293031323334353637// 这时我们可以使用`UIFocusGuide`来做个连接，打通topRight与bottomLeft间的隔阂。let focusGuide = UIFocusGuide()view.addLayoutGuide(focusGuide) // Anchor the top left of the focus guide.focusGuide.leftAnchor.constraint(equalTo: topRightButton.leftAnchor).isActive = truefocusGuide.topAnchor.constraint(equalTo: bottomLeftButton.topAnchor).isActive = true // Anchor the width and height of the focus guide.focusGuide.widthAnchor.constraint(equalTo: topRightButton.widthAnchor).isActive = truefocusGuide.heightAnchor.constraint(equalTo: bottomLeftButton.heightAnchor).isActive = true// MARK: UIFocusEnvironment override func didUpdateFocus(in context: UIFocusUpdateContext, with coordinator: UIFocusAnimationCoordinator) &#123; super.didUpdateFocus(in: context, with: coordinator) /* Update the focus guide's `preferredFocusedView` depending on which button has the focus. */ guard let nextFocusedView = context.nextFocusedView else &#123; return &#125; switch nextFocusedView &#123; // topRIghtButton向下时focusGuide指向bottomLeftButton case topRightButton: focusGuide.preferredFocusEnvironments = [bottomLeftButton] // bottomLeftButton向上时focusGuide指向topRightButton case bottomLeftButton: focusGuide.preferredFocusEnvironments = [topRightButton] default: focusGuide.preferredFocusEnvironments = [] &#125;&#125; UICollectionView的聚焦问题 自定义聚焦位置 12345678910111213// MARK: collectview聚焦func collectionView(_ collectionView: UICollectionView, didUpdateFocusIn context: UICollectionViewFocusUpdateContext, with coordinator: UIFocusAnimationCoordinator) &#123; if let collectionViewFocused = self.isFocusedCollectionViewAction &#123; collectionViewFocused(context.nextFocusedView! is CGTNCollectionViewCell) &#125; &#125;// MARK: 定义聚焦位置func indexPathForPreferredFocusedView(in collectionView: UICollectionView) -&gt; IndexPath? &#123; return IndexPath(item: 1, section: 0)&#125; 记住聚焦位置 1234567891011121314151617let collectionV = UICollectionView(frame:bounds, collectionViewLayout: flowLayout)collectionV.isScrollEnabled = falsecollectionV.delegate = selfcollectionV.dataSource = self/* * defaults to NO. * If YES, when focusing on a collection view the * last focused index path is focused automatically. * If the collection view has never been focused, * then the preferred focused index path is used. */collectionV.remembersLastFocusedIndexPath = trueaddSubview(collectionV)......]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RunLoop]]></title>
      <url>%2F2017%2F07%2F06%2FRunLoop%2F</url>
      <content type="text"><![CDATA[这是一次电话面试的问题，当时很模糊，感觉作为一个iOS开发者还是要做一个了解，下面借助度娘总结一下，用的着的点赞。 什么是RunnLoopRunLoop是一个”死”循环，应为有它的存在，保证了App能够持续运行。在一个iOS程序启动后，在UIApplicationMain函数内部启动一个跟主线程相关的RunnLoop对象，而UIApplicationMain函数一直运行从而保证程序一直运行。通过所有的“消息”都被添加到了RunLoop中去，而在这里这些消息又分为“input source”和“Timer source” 并在循环中检查是不是有事件需要发生，如果需要那么就调用相应的函数处理。由此形成了运行-&gt;检测-&gt;休眠 -&gt;运行 的循环状态。 主要作用 使程序一直运行并接受用户输入 决定程序在何时处理一些事件 条件解耦，消息队列 节省CPU资源，有事时处理，没事是休眠 RunLoop与线程之间的关系RunLoop是用来管理线程的。每一个线程都有一个RunLoop对象。可以通过具体的方法去获得。但是需要注意：虽然每一个线程都可以获取RUnLoop对象，但是并不是每一个线程中都有实例对象，我们可以这样理解：如果我们不获取RunLoop，这个RunLoop就不存在，我们获取时，如果不存在，就会去创建。在主线程中，这个主RunLoop是默认创建并运行激活的。 iOS开辟线程占用的空间情况线程创建的成本：1234kernel data structures 约1KBStack space 512KB(secondary threads) 1MB(iOS main thread)Creation time 约90 microseconds 当编写线程代码时另外一个需要考虑的成本是生产成本。线程的滥用会占用大量的内存，使用需谨慎。 ModeMode中有三个非常重要的组成部分，Timer(定时器)、Source(事件源)以及Observor(观察者)。一个RunLoop包含若干个Mode，每个Mode又包含若干个Source/Timer/Observer。首先要指出的是一个runloop启动时必须指定一个Mode,并且这个Mode被称为currentMode。如果要切换Mode,只能退出runloop重新进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。随后我们会分别介绍每一类的具体作用与应用场景。系统默认注册的Mode有五种12345678910kCFRunloopDefaultMode // App默认Mode 通常主线程是在这个mode下运行UITrackingRunloopMode // 界面跟踪Mode 用于scrollView追踪触摸 界面滑动时不受其他Mode影响UIinitializationRunloopMode //在app一启动进入的第一个Mode,启动完成后就不再使用GSEventRecieveRunloopMode //苹果使用绘图相关NSRunLoopCommonModes //占位模式 实际应用只在NSRUnloopDefaultModes 下显示图片1234//在cell里面把设置图片的事情在NSDefaultRunloopMode里面去做。//当主线程的tableview不再滑动的时候就会去设置图片UIImage *dowloadImage = ...;[self.iconImageView performSelector:@selector(setImage:) withObject:dowloadImage afterDelay:0 inModes:@[NSDefaultRunloopMode]]; NSTimer NSRunLoopCommonModes1234567self.timer = [NSTimer scheduledTimerWithTimeInterval:0.0625 target:self selector:@selector(progressChange) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes]; 这样声明的NSTimer可以解决在滑动scrollView时NSTimer不工作的问题。forMode:NSRunLoopCommonModes的意思为，定时器可以运行在标记为common modes模式下。具体包括两种: kCFRunloopDefaultMode和UITrackingRunloopMode。当你开始滑动UIScrollView时，RunLoop的mode状态变化如下：1NSDefaultRunLoopMode -&gt; UITrackingRunLoopMode -&gt; NSDefaultRunLoopMode RunLoop与GCD定时器GCD定时器的优势:不受RunLoop的运行模式的影响12345678910111213141516171819202122232425262728293031323334class ViewController: NSViewController &#123;var timerSource:DispatchSourceTimer!var isStop:Bool = falseoverride func viewDidLoad() &#123; super.viewDidLoad() // DispatchSourceTimer let timer = DispatchSource.makeTimerSource(flags: [], queue: DispatchQueue.main) timerSource = timer // 注意:需要保持拥有，不然会立即释放掉 timerSource.scheduleRepeating(deadline: .now(), interval: .microseconds(40)) timerSource.setEventHandler &#123; print("Hello") &#125; timerSource.resume() // Timer // time会被添加到RunnLoop当中，不需要保持拥有 let time = Timer(fire: Date.distantPast, interval: 0.5, repeats: true) &#123; (time) in print("Timer") &#125; RunLoop.current.add(time, forMode: .defaultRunLoopMode) &#125;@IBAction func stop(_ sender: NSButton) &#123; if isStop &#123; timerSource.resume() &#125; else &#123; timerSource.suspend() &#125; isStop = !isStop&#125; AFNetworking 常驻线程通常执行完方法后线程就销毁了，那么现在有这样的需求，需要一条子线程一直存在，等待处理任务，与主线程之间互不干扰 (可以类比主线程存在原理，即添加消息循环Runloop)123456789101112131415161718192021222324+ (void)networkRequestThreadEntryPoint:(id)_unuserd object &#123; @autoreleasepool &#123; [[NSThread currentThread] setName:@"AFNetworking"]; //为了不让runloop run起来没事干导致消失 //所以给runloop加了一个NSMachPort，给它一个mode去监听 //实际上port什么也没干，就是让runloop一直在等，目的就是让runloop一直活着 //这是一个创建常驻服务线程的好方法 NSRunloop *runloop = [NSRunLoop currentRunLoop]; [runloop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runloop run]; &#125;&#125;+ (NSThread *)networkRequestThread &#123; static NSThread *_networkReuqestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^&#123; _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; &#125;); return _networkRequestThread;&#125; Ps:Runloop运行首先判断Mode是否为空，如果为空则退出循环，还可以通过removePort来移除端口。本例用添加port来实现，其他方法请读者自己多尝试。 关于自动释放池关于自动释放池，子线程开启runloop时要开启针对当前线程的autoreleasepool，在每次NSRunloop休眠前清理自动释放池。 参考文章:1.浅谈NSRunloop工作原理和相关应用2.iOS NSRunloop详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git使用总结]]></title>
      <url>%2F2017%2F06%2F07%2FGit%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[Git的命令的使用，上传代码到远程与更新远程代码到本地仓库. 使用Git上传代码到远程库 建立git仓库 123cd到你的本地项目根目录下，执行git命令git init 将项目的所有文件添加到仓库中 1git add . 如果想添加某个特定的文件，只需把.换成特定的文件名即可 将add的文件commit到仓库 1git commit -m "注释语句" 去github上创建自己的Repository，拿到仓库地址https 将本地的仓库关联到Github上 12git remote add origin https://仓库地址移除仓库：git remote rm origin 上传github之前 要先pull一下 执行如下命令 1git pull --rebase origin master 上传代码到github远程仓库 1git push -u origin master 更新远程代码到本地仓库方式一 查看远程仓库 1234$ git remote -vorigin https://github.com/HC1058503505/HCCardView.git (fetch)origin https://github.com/HC1058503505/HCCardView.git (push) 从远程获取最新版本到本地 12// 从远程的origin仓库的master分支下载代码到本地的origin master$ git fetch origin master 比较本地常看远程仓库的区别 12345678910111213141516171819202122232425$ git log -p master.. origin/master// 结果如下commit 4d89094a5b01e29ab6f5f2e8bfbe5c944059840bAuthor: HC1058503505 &lt;1058503505@qq.com&gt;Date: Tue Jun 6 17:58:11 2017 +0800 Update README.mddiff --git a/README.md b/README.mdindex cd16927..7907a33 100644--- a/README.md+++ b/README.md@@ -136,8 +136,89 @@ extension HCCardHeaderView:HCCardContentViewDelegate &#123; * UICollectionView的自定义布局- &gt; 自定义布局的实现步骤- 1.// MARK: - 准备布局- 2.// MARK: - 返回布局- 3.// MARK: - 布局作用范围++自定义布局的实现步骤+1.// MARK: - 准备布局+extension HCCollectionViewFlowLayout &#123;+ override func prepare() &#123; 远程与本地仓库合并 1$ git merge origin/master 方式二 查看远程分支，和方式一相同 从远程获取最新版本到本地 12// 从远程的origin仓库的master分支下载到本地并新建一个分支temp$ git fetch origin master:temp 比较本地仓库和远程仓库的区别 1$ git diff temp 合并temp分支到master 1$ git merge temp 如果不想要temp分支，可以删除 1git branch -d temp 参考链接：git fetch 的简单用法:更新远程代码到本地仓库]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS7+ 实现全屏POP手势]]></title>
      <url>%2F2017%2F05%2F27%2FiOS7-%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%8FPOP%E6%89%8B%E5%8A%BF%2F</url>
      <content type="text"><![CDATA[我们知道, iOS7的导航控制器有一个自带的pop手势(interactivePopGestureRecognizer), 该手势允许我们从屏幕左侧向右滑动来pop掉当前的栈顶控制器. 事实上, 我们看到国内许多app就是采用了系统自带的这个recognizer, 并没有定制切换效果. 而也有很多app(如最新版的网易新闻)在维持系统pop效果的前提下, 把手势响应区域扩展到全屏!这里对这一实现过程进行总结。 问题发掘导航栏的pop手势只能够响应左侧有限的区域内，内部实现时肯定是做了限制，这种限制应该也是对手势属性值或方法的设置来实现，那么我们需要看一下该手势的具体实现，当然是使用runtime。123456789101112131415161718192021let gesture = navigationController?.interactivePopGestureRecognizerprint("gesture的类名:\(NSStringFromClass((gesture?.classForCoder)!))")print("gesture的父类名:\(NSStringFromClass((gesture?.superclass)!))")var ivarCount:UInt32 = 0let ivarList = class_copyIvarList(gesture?.classForCoder, &amp;ivarCount)for i in 0 ..&lt; ivarCount &#123; let ivar = ivarList![Int(i)] let name = ivar_getName(ivar) print("class_copyIvarList---\(String(cString: name!, encoding: .utf8) ?? "")")&#125;free(ivarList)var proprtyCount:UInt32 = 0let propertyList = class_copyPropertyList(gesture?.classForCoder, &amp;proprtyCount)for i in 0 ..&lt; proprtyCount &#123; let property = propertyList![Int(i)] print("class_copyPropertyList---\(String(cString: property_getName(property), encoding: .utf8) ?? "")")&#125;free(propertyList) 结果如下：12345678gesture的类名:UIScreenEdgePanGestureRecognizergesture的父类名:UIPanGestureRecognizerclass_copyIvarList---_recognizerclass_copyPropertyList---edgesclass_copyPropertyList---hashclass_copyPropertyList---superclassclass_copyPropertyList---descriptionclass_copyPropertyList---debugDescription 可见是UIScreenEdgePanGestureRecognizer私有类的edges属性决定了pop手势的作用范围。我们怎么利用这一特性呢？ 设置其edges达到全屏pop 想想我们添加手势处理事件时需要target-action,我们可以利用该手势的targe-action 这里第一种方法以后尝试，我们现在使用第二种方法来实现。 寻找target-action由上图可知，interactivePopGestureRecognizer的类型为UIGestureRecognizer,所以12345678910var ivarGesture:UInt32 = 0let ivarGestureList = class_copyIvarList(UIGestureRecognizer.self, &amp;ivarGesture)for i in 0 ..&lt; ivarGesture &#123; let ivar = ivarGestureList![Int(i)] let name = ivar_getName(ivar) let type = ivar_getTypeEncoding(ivar) print("ivarGestureName---\(String(cString: name!, encoding: .utf8) ?? "") ivarGestureType:\(String(cString: type!, encoding: .utf8) ?? "")")&#125;free(ivarGestureList) 结果如下：12345678910111213141516171819202122ivarGestureName---_gestureFlags ivarGestureType:&#123;?="delegateShouldBegin"b1"delegateCanPrevent"b1"delegateCanBePrevented"b1"delegateShouldRecognizeSimultaneously"b1"delegateShouldReceiveTouch"b1"delegateShouldReceivePress"b1"delegateShouldRequireFailure"b1"delegateShouldBeRequiredToFail"b1"delegateFailed"b1"privateDelegateShouldBegin"b1"privateDelegateCanPrevent"b1"privateDelegateCanBePrevented"b1"privateDelegateShouldRecognizeSimultaneously"b1"privateDelegateShouldReceiveTouch"b1"privateDelegateShouldReceivePress"b1"privateDelegateShouldRequireFailure"b1"privateDelegateShouldBeRequiredToFail"b1"subclassShouldRequireFailure"b1"subclassShouldBeRequiredToFail"b1"hasSubclassDynamicFailureRequirements"b1"hasDelegateDynamicFailureRequirements"b1"subclassTouchesEstimatedPropertiesUpdated"b1"queriedFailureRequirements"b1"cancelsTouchesInView"b1"delaysTouchesBegan"b1"delaysTouchesEnded"b1"disabled"b1"dirty"b1"delivered"b1"deliveredEndedOrCancelled"b1"continuous"b1"requiresDelayedBegan"b1"willBeginAfterSatisfyingFailureRequirements"b1"requiresSystemGesturesToFail"b1"acceptsFailureRequirements"b1"requiresExclusiveTouchType"b1"initialTouchTypeIsValid"b1"forceRequirementSatisfied"b1&#125;ivarGestureName---_targets ivarGestureType:@"NSMutableArray"ivarGestureName---_delayedTouches ivarGestureType:@"NSMutableArray"ivarGestureName---_delayedPresses ivarGestureType:@"NSMutableArray"ivarGestureName---_view ivarGestureType:@"UIView"ivarGestureName---_lastTouchTimestamp ivarGestureType:divarGestureName---_state ivarGestureType:qivarGestureName---_allowedTouchTypes ivarGestureType:qivarGestureName---_initialTouchType ivarGestureType:qivarGestureName---_internalActiveTouches ivarGestureType:@"NSMutableSet"ivarGestureName---_forceClassifier ivarGestureType:@"_UIForceLevelClassifier"ivarGestureName---_requiredPreviewForceState ivarGestureType:qivarGestureName---_touchForceObservable ivarGestureType:@"_UITouchForceObservable"ivarGestureName---_touchForceObservableAndClassifierObservation ivarGestureType:@"NSObservation"ivarGestureName---_forceTargets ivarGestureType:@"NSMutableArray"ivarGestureName---_forcePressCount ivarGestureType:QivarGestureName---_beganObservable ivarGestureType:@"NSObservationSource"ivarGestureName---_failureRequirements ivarGestureType:@"NSMutableSet"ivarGestureName---_failureDependents ivarGestureType:@"NSMutableSet"ivarGestureName---_delegate ivarGestureType:@"&lt;UIGestureRecognizerDelegate&gt;"ivarGestureName---_allowedPressTypes ivarGestureType:@"NSArray"ivarGestureName---_gestureEnvironment ivarGestureType:@"UIGestureEnvironment" 我猜_targets就是我们要找的，感觉离成功不远了12345// 获取targetslet targets = navigationController?.interactivePopGestureRecognizer?.value(forKeyPath: "_targets") as! Array&lt;Any&gt;for target in targets &#123; print(target)&#125; 结果如下：1(action=handleNavigationTransition:, target=&lt;_UINavigationInteractiveTransition 0x7fe95d514850&gt;) 成功，action，target全部拿到，下面就是添加我们自己的手势然后设置action，target。123456789// 全屏pop手势let targets = navigationController?.interactivePopGestureRecognizer?.value(forKeyPath: "_targets") as! Array&lt;Any&gt;let obj = targets.last! // (action=handleNavigationTransition:, target=&lt;_UINavigationInteractiveTransition 0x7fe95d514850&gt;)let selector = Selector(("handleNavigationTransition:"))let target = (obj as AnyObject).value(forKeyPath: "target") // navigationController?.interactivePopGestureRecognizer?.delegatelet pan = UIPanGestureRecognizer(target: target, action: selector)view.addGestureRecognizer(pan) 最后经尝试发现interactivePopGestureRecognizer的代理就是pop手势的target。 参考链接：KVC实现全屏pop手势(iOS7+)喵神-iOS7中的ViewController切换]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML速查表]]></title>
      <url>%2F2017%2F05%2F17%2FHTML%E9%80%9F%E6%9F%A5%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[HTML速查表，以备日常使用。 HTML基本文档123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;文档标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 可见文本... &lt;/body&gt;&lt;/html&gt; 基本标签1234567891011&lt;h1&gt;最大的标题&lt;/h1&gt;&lt;h2&gt; . . . &lt;/h2&gt;&lt;h3&gt; . . . &lt;/h3&gt;&lt;h4&gt; . . . &lt;/h4&gt;&lt;h5&gt; . . . &lt;/h5&gt;&lt;h6&gt;最小的标题&lt;/h6&gt; &lt;p&gt;这是一个段落。&lt;/p&gt;&lt;br&gt; （换行）&lt;hr&gt; （水平线）&lt;!-- 这是注释 --&gt; 文本格式化123456789101112131415161718&lt;b&gt;粗体文本&lt;/b&gt;&lt;code&gt;计算机代码&lt;/code&gt;&lt;em&gt;强调文本&lt;/em&gt;&lt;i&gt;斜体文本&lt;/i&gt;&lt;kbd&gt;键盘输入&lt;/kbd&gt; &lt;pre&gt;预格式化文本&lt;/pre&gt;&lt;small&gt;更小的文本&lt;/small&gt;&lt;strong&gt;重要的文本&lt;/strong&gt; &lt;abbr&gt; （缩写）&lt;address&gt; （联系信息）&lt;bdo&gt; （文字方向）&lt;blockquote&gt; （从另一个源引用的部分）&lt;cite&gt; （工作的名称）&lt;del&gt; （删除的文本）&lt;ins&gt; （插入的文本）&lt;sub&gt; （下标文本）&lt;sup&gt; （上标文本） 链接123456普通的链接：&lt;a href="http://www.example.com/"&gt;链接文本&lt;/a&gt;图像链接： &lt;a href="http://www.example.com/"&gt;&lt;img src="URL" alt="替换文本"&gt;&lt;/a&gt;邮件链接： &lt;a href="mailto:webmaster@example.com"&gt;发送e-mail&lt;/a&gt;书签：&lt;a id="tips"&gt;提示部分&lt;/a&gt;&lt;a href="#tips"&gt;跳到提示部分&lt;/a&gt; 图片1&lt;img src="URL" alt="替换文本" height="42" width="42"&gt; 样式、区块123456&lt;style type="text/css"&gt;h1 &#123;color:red;&#125;p &#123;color:blue;&#125;&lt;/style&gt;&lt;div&gt;文档中的块级元素&lt;/div&gt;&lt;span&gt;文档中的内联元素&lt;/span&gt; 列表12345678910111213141516171819&lt;! -- 无序列表 --&gt;&lt;ul&gt; &lt;li&gt;项目&lt;/li&gt; &lt;li&gt;项目&lt;/li&gt;&lt;/ul&gt;&lt;! -- 有序列表 --&gt;&lt;ol&gt; &lt;li&gt;第一项&lt;/li&gt; &lt;li&gt;第二项&lt;/li&gt;&lt;/ol&gt;&lt;! -- 自定义列表 --&gt;&lt;dl&gt; &lt;dt&gt;项目 1&lt;/dt&gt; &lt;dd&gt;描述项目 1&lt;/dd&gt; &lt;dt&gt;项目 2&lt;/dt&gt; &lt;dd&gt;描述项目 2&lt;/dd&gt;&lt;/dl&gt; 表格12345678910&lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格数据&lt;/td&gt; &lt;td&gt;表格数据&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 框架1234567891011&lt;! DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe src="form.html" height="300" width="100%" name="iframe-a"&gt;&lt;/iframe&gt; &lt;p&gt;&lt;a href="http://www.runoob.com" target="iframe-a"&gt;go&lt;/a&gt;&lt;/p&gt; &lt;br/&gt; &lt;p&gt;&lt;a href="form.html" target="iframe-a"&gt;back&lt;/a&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 表单12345678910111213141516&lt;form action="demo_form.php" method="post/get"&gt;&lt;input type="text" name="email" size="40" maxlength="50"&gt;&lt;input type="password"&gt;&lt;input type="checkbox" checked="checked"&gt;&lt;input type="radio" checked="checked"&gt;&lt;input type="submit" value="Send"&gt;&lt;input type="reset"&gt;&lt;input type="hidden"&gt;&lt;select&gt;&lt;option&gt;苹果&lt;/option&gt;&lt;option selected="selected"&gt;香蕉&lt;/option&gt;&lt;option&gt;樱桃&lt;/option&gt;&lt;/select&gt;&lt;textarea name="comment" rows="60" cols="20"&gt;&lt;/textarea&gt; &lt;/form&gt; 实体字符串123&amp;lt; 等同于 &lt;&amp;gt; 等同于 &gt;&amp;#169; 等同于 ©]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS动画]]></title>
      <url>%2F2017%2F04%2F28%2FiOS%E5%8A%A8%E7%94%BB%2F</url>
      <content type="text"><![CDATA[本章主要介绍iOS动画的基本使用，是通过一个一个实例来介绍iOS动画的基本使用。 UIView Animation1234567891011121314151617181920212223242526272829// 1.添加LabelUILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(100, 300, 100, 100)];label.numberOfLines = 0;label.text = @"UIViewAnimation";label.backgroundColor = [UIColor orangeColor];label.userInteractionEnabled = true;[self.view addSubview:label];// 2.添加手势UITapGestureRecognizer *gesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapAction:)];[label addGestureRecognizer:gesture];// 3.执行动画- (void)tapAction:(UIGestureRecognizer *)gesture &#123; CGPoint endPoint = CGPointMake(gesture.view.layer.position.x + 100, gesture.view.layer.position.y); [UIView animateWithDuration:1.0 animations:^&#123; gesture.view.layer.position = endPoint; &#125;];// [UIView animateWithDuration:1.0 animations:^&#123;// &#125; completion:^(BOOL finished) &#123;// &#125;];// // 延迟动画// [UIView animateWithDuration:1.0 delay:0.5 options:UIViewAnimationOptionCurveEaseInOut animations:^&#123;// &#125; completion:^(BOOL finished) &#123;// &#125;];&#125; CoreAnimation CAAnimation：核心动画的基础类，不能直接使用，负责动画运行时间、速度的控制，本身实现了CAMediaTiming协议。 CAPropertyAnimation：属性动画的基类（通过属性进行动画设置，注意是可动画属性），不能直接使用。 CAAnimationGroup：动画组，动画组是一种组合模式设计，可以通过动画组来进行所有动画行为的统一控制，组中所有动画效果可以并发执行。 CATransition：转场动画，主要通过滤镜进行动画效果设置。 CABasicAnimation：基础动画，通过属性修改进行动画参数控制，只有初始状态和结束状态。 CAKeyframeAnimation：关键帧动画，同样是通过属性进行动画参数控制，但是同基础动画不同的是它可以有多个状态控制。 CABaseAnimation1234567891011121314151617181920212223242526272829303132333435// 1.添加viewUIView *redView = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];self.redView = redView;redView.backgroundColor = [UIColor redColor];[self.view addSubview:redView];// 2.添加手势UITapGestureRecognizer *gesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapAction:)];[redView addGestureRecognizer:gesture];- (void)tapAction:(UIGestureRecognizer *)gesture &#123; CGPoint endPoint = CGPointMake(gesture.view.layer.position.x + 100, gesture.view.layer.position.y); CGPoint startPoint = gesture.view.layer.position; // 创建动画实例 CABasicAnimation *baseAnimation = [CABasicAnimation animationWithKeyPath:@"position"]; // 设置动画代理 baseAnimation.delegate = self; // 动画起始位置 baseAnimation.fromValue = [NSValue valueWIthCGPoint:startPoint]; // 动画结束位置 baseAnimation.toValue = [NSValue valueWithCGPoint:endPoint]; // 动画执行时长 // baseAnimation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn)//加速运动 // baseAnimation.timingFunction = CAMediaTimingFunction(controlPoints: 0.5, 0, 0.9, 0.7)//自定义加速的曲线参数 baseAnimation.duration = 1.0; // 设置动画执行测试 baseAnimation.repeatCount = 1; // 在动画中存储一些必要数据 [baseAnimation setValue:[NSValue valueWithCGPoint:endPoint] forKey:@"redView"]; // 避免动画执行后回复位 baseAnimation.removedOnCompletion = false; baseAnimation.fillMode = kCAFillModeForwards; // 图层添加动画 gesture.view.layer addAnimation:baseAnimation forKey:nil]; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS蓝牙开发(三)]]></title>
      <url>%2F2017%2F04%2F25%2FiOS%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91-%E4%B8%89%2F</url>
      <content type="text"><![CDATA[app作为外设被连接的实现 外设模式流程123456创建外设管理者实例开启本地设备的服务和特征发布你的服务和特征到你的设备本地数据库广播你的服务响应其他中心设备的读写请求发送最新的特征值去订阅中心设备 实现步骤创建外设管理者123456/* 和CBCentralManager类似，蓝牙设备打开需要一定时间，打开成功后会进入委托方法 - (void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral; 模拟器永远也不会得CBPeripheralManagerStatePoweredOn状态*/peripheralManager = [[CBPeripheralManager alloc]initWithDelegate:self queue:nil]; 创建本地设备的服务和特征 在委托方法- (void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral中，当peripheral成功打开后，才可以配置service和characteristics。这里创建的service和chara对象是CBMutableCharacteristic和CBMutableService。他们的区别就像NSArray和NSMutableArray区别类似。 我们先创建characteristics和description，description是characteristics的描述，描述分很多种， 这里不细说了，常用的就是CBUUIDCharacteristicUserDescriptionString。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//peripheralManager状态改变- (void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral&#123; switch (peripheral.state) &#123; //在这里判断蓝牙设别的状态 当开启了则可调用 setUp方法(自定义) case CBPeripheralManagerStatePoweredOn: NSLog(@"powered on"); [info setText:[NSString stringWithFormat:@"设备名%@已经打开，可以使用center进行连接",LocalNameKey]]; [self setUp]; break; case CBPeripheralManagerStatePoweredOff: NSLog(@"powered off"); [info setText:@"powered off"]; break; default: break; &#125;&#125;//配置bluetooch的-(void)setUp&#123; //characteristics字段描述 CBUUID *CBUUIDCharacteristicUserDescriptionStringUUID = [CBUUID UUIDWithString:CBUUIDCharacteristicUserDescriptionString]; /* 可以通知的Characteristic properties：CBCharacteristicPropertyNotify permissions CBAttributePermissionsReadable */ CBMutableCharacteristic *notiyCharacteristic = [[CBMutableCharacteristic alloc]initWithType:[CBUUID UUIDWithString:notiyCharacteristicUUID] properties:CBCharacteristicPropertyNotify value:nil permissions:CBAttributePermissionsReadable]; /* 可读写的characteristics properties：CBCharacteristicPropertyWrite | CBCharacteristicPropertyRead permissions CBAttributePermissionsReadable | CBAttributePermissionsWriteable */ CBMutableCharacteristic *readwriteCharacteristic = [[CBMutableCharacteristic alloc]initWithType:[CBUUID UUIDWithString:readwriteCharacteristicUUID] properties:CBCharacteristicPropertyWrite | CBCharacteristicPropertyRead value:nil permissions:CBAttributePermissionsReadable | CBAttributePermissionsWriteable]; //设置description CBMutableDescriptor *readwriteCharacteristicDescription1 = [[CBMutableDescriptor alloc]initWithType: CBUUIDCharacteristicUserDescriptionStringUUID value:@"name"]; [readwriteCharacteristic setDescriptors:@[readwriteCharacteristicDescription1]]; /* 只读的Characteristic properties：CBCharacteristicPropertyRead permissions CBAttributePermissionsReadable */ CBMutableCharacteristic *readCharacteristic = [[CBMutableCharacteristic alloc]initWithType:[CBUUID UUIDWithString:readCharacteristicUUID] properties:CBCharacteristicPropertyRead value:nil permissions:CBAttributePermissionsReadable]; //service1初始化并加入两个characteristics CBMutableService *service1 = [[CBMutableService alloc]initWithType:[CBUUID UUIDWithString:ServiceUUID1] primary:YES]; [service1 setCharacteristics:@[notiyCharacteristic,readwriteCharacteristic]]; //service2初始化并加入一个characteristics CBMutableService *service2 = [[CBMutableService alloc]initWithType:[CBUUID UUIDWithString:ServiceUUID2] primary:YES]; [service2 setCharacteristics:@[readCharacteristic]]; //添加后就会调用代理的- (void)peripheralManager:(CBPeripheralManager *)peripheral didAddService:(CBService *)service error:(NSError *)error [peripheralManager addService:service1]; [peripheralManager addService:service2];&#125; 开启广播123456789101112131415161718192021222324//perihpheral添加了service- (void)peripheralManager:(CBPeripheralManager *)peripheral didAddService:(CBService *)service error:(NSError *)error&#123; if (error == nil) &#123; serviceNum++; &#125; //因为我们添加了2个服务，所以想两次都添加完成后才去发送广播 if (serviceNum==2) &#123; //添加服务后可以在此向外界发出通告 调用完这个方法后会调用代理的 //(void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheral error:(NSError *)error [peripheralManager startAdvertising:@&#123; CBAdvertisementDataServiceUUIDsKey : @[[CBUUID UUIDWithString:ServiceUUID1],[CBUUID UUIDWithString:ServiceUUID2]], CBAdvertisementDataLocalNameKey : LocalNameKey &#125; ]; &#125; &#125;//peripheral开始发送advertising- (void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheral error:(NSError *)error&#123; NSLog(@"in peripheralManagerDidStartAdvertisiong");&#125; 对中心设备请求的响应 读characteristics请求写characteristics请求订阅和取消订阅characteristics 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//订阅characteristics-(void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didSubscribeToCharacteristic:(CBCharacteristic *)characteristic&#123; NSLog(@"订阅了 %@的数据",characteristic.UUID); //每秒执行一次给主设备发送一个当前时间的秒数 timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(sendData:) userInfo:characteristic repeats:YES];&#125;//取消订阅characteristics-(void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didUnsubscribeFromCharacteristic:(CBCharacteristic *)characteristic&#123; NSLog(@"取消订阅 %@的数据",characteristic.UUID); //取消回应 [timer invalidate];&#125;//发送数据，发送当前时间的秒数-(BOOL)sendData:(NSTimer *)t &#123; CBMutableCharacteristic *characteristic = t.userInfo; NSDateFormatter *dft = [[NSDateFormatter alloc]init]; [dft setDateFormat:@"ss"]; NSLog(@"%@",[dft stringFromDate:[NSDate date]]); //执行回应Central通知数据 return [peripheralManager updateValue:[[dft stringFromDate:[NSDate date]] dataUsingEncoding:NSUTF8StringEncoding] forCharacteristic:(CBMutableCharacteristic *)characteristic onSubscribedCentrals:nil]; &#125;//读characteristics请求- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveReadRequest:(CBATTRequest *)request&#123; NSLog(@"didReceiveReadRequest"); //判断是否有读数据的权限 if (request.characteristic.properties &amp; CBCharacteristicPropertyRead) &#123; NSData *data = request.characteristic.value; [request setValue:data]; //对请求作出成功响应 [peripheralManager respondToRequest:request withResult:CBATTErrorSuccess]; &#125;else&#123; [peripheralManager respondToRequest:request withResult:CBATTErrorWriteNotPermitted]; &#125;&#125;//写characteristics请求- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveWriteRequests:(NSArray *)requests&#123; NSLog(@"didReceiveWriteRequests"); CBATTRequest *request = requests[0]; //判断是否有写数据的权限 if (request.characteristic.properties &amp; CBCharacteristicPropertyWrite) &#123; //需要转换成CBMutableCharacteristic对象才能进行写值 CBMutableCharacteristic *c =(CBMutableCharacteristic *)request.characteristic; c.value = request.value; [peripheralManager respondToRequest:request withResult:CBATTErrorSuccess]; &#125;else&#123; [peripheralManager respondToRequest:request withResult:CBATTErrorWriteNotPermitted]; &#125; &#125; 程序运行流程图如下: 原文地址：Kenshin Cuiliuyanwei第三方框架：BabyBluetooth]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS蓝牙开发(二)]]></title>
      <url>%2F2017%2F04%2F25%2FiOS%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91-%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[iOS蓝牙中心模式连接外设，数据接收及发送。 连接外设流程12345建立Central Manager实例进行蓝牙管理搜索,连接外设获取外设的服务,特征向外设特征值发送读取和写入请求订阅一特征值去监控其变化 实现步骤创建蓝牙管理者 CBCentralManager是Core Bluetooth的一个对象，代表一个本地中心设备，在使用蓝牙前，需要创建CBCenterManager实例。 1centralM = [[CBCentralManager alloc] initWithDelegate:self queue:nil options:nil]; 创建蓝牙管理者时,self会被设置为接收中心设备所有事件的代理者，参数queue设置为nil后，centralM会通过主线程来处理事件。控制器需要实现CBCentralManagerDelegate、CBPeripheralDelegate这两个代理。当创建了一个蓝牙管理者，会回调代理的centralManagerDidUpdateState:方法，你必须实现这个代理方法来确定中心设备是否支持BLE以及是否可用。1234567891011121314151617181920212223242526- (void)centralManagerDidUpdateState:(CBCentralManager *)central &#123; switch (central.state) &#123; case CBManagerStateUnknown: // 蓝牙状态未知 State unknown, update imminent. NSLog(@"&gt;&gt;&gt;CBManagerStateUnknown"); break; case CBManagerStateResetting: // 蓝牙重置 The connection with the system service was momentarily lost, update imminent. NSLog(@"&gt;&gt;&gt;CBManagerStateResetting"); break; case CBManagerStateUnsupported: // 不支持 The platform doesn't support the Bluetooth Low Energy Central/Client role. NSLog(@"&gt;&gt;&gt;CBManagerStateUnsupported"); break; case CBManagerStateUnauthorized: // 未授权 The application is not authorized to use the Bluetooth Low Energy role. NSLog(@"&gt;&gt;&gt;CBManagerStateUnauthorized"); break; case CBManagerStatePoweredOff: // 蓝牙未开启 Bluetooth is currently powered off. NSLog(@"&gt;&gt;&gt;CBManagerStatePoweredOff"); break; default: // 蓝牙开启状态，可使用 Bluetooth is currently powered on and available to use. NSLog(@"&gt;&gt;&gt;CBManagerStatePoweredOn"); // 开始扫描外设 // 如果你指定第一个参数为nil,centralM会返回发现的所有设备. // 实际开发中，你需要指定一个`CBUUID`对象数组,数组中每一个对象对应一个唯一的外设的服务 [centralM scanForPeripheralsWithServices:nil options:nil]; break; &#125;&#125; 搜索连接外设 调用了scanForPeripheralsWithServices:options:方法来搜索可连接的外围设备后,centralM在每次搜索到一个外围设备都会回调其代理的centralManager:didDiscoverPeripheral:advertisementData:RSSI: 方法。任何被搜索到的外围设备都以CBPeripheral类的方式返回。像下面的代码，你可以实现这个代理方法来罗列出所有被搜索到的蓝牙设备 1234567891011121314151617181920212223242526272829303132- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&lt;NSString *,id&gt; *)advertisementData RSSI:(NSNumber *)RSSI &#123; NSLog(@"%@",peripheral.name); if (peripheral.name.length &gt; 0) &#123; // 找到的设备必须持有它，否则CBCentralManager中也不会保存peripheral，那么CBPeripheralDelegate中的方法也不会被调用！！ [peripherals addObject:peripheral]; // [manager stopScan]; // 根据需求可以停止搜索其他外设 [centralM connectPeripheral:peripheral options:nil]; // 连接外设 &#125;&#125; //连接到Peripherals-成功 - (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral&#123; NSLog(@"&gt;&gt;&gt;连接到名称为（%@）的设备-成功",peripheral.name); // 设置外设代理 [peripheral setDelegate:self]; // 搜索外设的服务 [peripheral discoverServices:nil]; &#125;//连接到Peripherals-失败-(void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error&#123; NSLog(@"&gt;&gt;&gt;连接到名称为（%@）的设备-失败,原因:%@",[peripheral name],[error localizedDescription]);&#125;//Peripherals断开连接- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error&#123; NSLog(@"&gt;&gt;&gt;外设连接断开连接 %@: %@\n", [peripheral name], [error localizedDescription]);&#125; 扫描外设中的服务器和特征 设备连接成功后，就可以扫描设备的服务了，同样是通过委托形式，扫描到结果后会进入委托方法。但是这个委托已经不再是主设备的委托CBCentralManagerDelegate,而是外设的委托CBPeripheralDelegate,这个委托包含了主设备与外设交互的许多回叫方法，包括获取services，获取characteristics，获取characteristics的值，获取characteristics的Descriptor，和Descriptor的值，写数据，读rssi，用通知的方式订阅数据等等。 获取外设的services1234567891011121314151617//扫描到Services-(void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error&#123; // NSLog(@"&gt;&gt;&gt;扫描到服务：%@",peripheral.services); if (error) &#123; NSLog(@"&gt;&gt;&gt;Discovered services for %@ with error: %@", peripheral.name, [error localizedDescription]); return; &#125; for (CBService *service in peripheral.services) &#123; NSLog(@"%@",service.UUID); // 扫描每个service的Characteristics，扫描到后会进入方法： // -(void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error [peripheral discoverCharacteristics:nil forService:service]; &#125;&#125; 获取服务的特征12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 搜索服务的特征- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error &#123; if (error) &#123; NSLog(@"error Discovered characteristics for %@ with error: %@", service.UUID, [error localizedDescription]); return; &#125; for (CBCharacteristic *characteristic in service.characteristics) &#123; NSLog(@"service:%@ 的 Characteristic: %@",service.UUID,characteristic.UUID); // 获取Characteristic的值，当你试图去读一个特征对应的值，外围设备会回调它的代理方法： // -(void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error [peripheral readValueForCharacteristic:characteristic]; // 搜索Characteristic的Descriptors，读到数据会进入方法： // -(void)peripheral:(CBPeripheral *)peripheral didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error [peripheral discoverDescriptorsForCharacteristic:characteristic]; &#125; &#125;// 获取的charateristic的值-(void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error&#123; //打印出characteristic的UUID和值 //!注意，value的类型是NSData，具体开发时，会根据外设协议制定的方式去解析数据 NSLog(@"characteristic uuid:%@ value:%@",characteristic.UUID,characteristic.value); &#125;//搜索到Characteristic的Descriptors-(void)peripheral:(CBPeripheral *)peripheral didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error&#123; //打印出Characteristic和他的Descriptors NSLog(@"characteristic uuid:%@",characteristic.UUID); for (CBDescriptor *d in characteristic.descriptors) &#123; NSLog(@"Descriptor uuid:%@",d.UUID); &#125; &#125;//获取到Descriptors的值-(void)peripheral:(CBPeripheral *)peripheral didUpdateValueForDescriptor:(CBDescriptor *)descriptor error:(NSError *)error&#123; //打印出DescriptorsUUID 和value //这个descriptor都是对于characteristic的描述，一般都是字符串，所以这里我们转换成字符串去解析 NSLog(@"characteristic uuid:%@ value:%@",[NSString stringWithFormat:@"%@",descriptor.UUID],descriptor.value);&#125; 把数据写到Characteristic中1234567891011121314151617181920212223242526272829303132333435-(void)writeCharacteristic:(CBPeripheral *)peripheral characteristic:(CBCharacteristic *)characteristic value:(NSData *)value&#123; //打印出 characteristic 的权限，可以看到有很多种，这是一个NS_OPTIONS，就是可以同时用于好几个值，常见的有read，write，notify，indicate，知知道这几个基本就够用了，前连个是读写权限，后两个都是通知，两种不同的通知方式。 /* typedef NS_OPTIONS(NSUInteger, CBCharacteristicProperties) &#123; CBCharacteristicPropertyBroadcast = 0x01, CBCharacteristicPropertyRead = 0x02, CBCharacteristicPropertyWriteWithoutResponse = 0x04, CBCharacteristicPropertyWrite = 0x08, CBCharacteristicPropertyNotify = 0x10, CBCharacteristicPropertyIndicate = 0x20, CBCharacteristicPropertyAuthenticatedSignedWrites = 0x40, CBCharacteristicPropertyExtendedProperties = 0x80, CBCharacteristicPropertyNotifyEncryptionRequired NS_ENUM_AVAILABLE(NA, 6_0) = 0x100, CBCharacteristicPropertyIndicateEncryptionRequired NS_ENUM_AVAILABLE(NA, 6_0) = 0x200 &#125;; */ NSLog(@"%lu", (unsigned long)characteristic.properties); //只有 characteristic.properties 有write的权限才可以写 if(characteristic.properties &amp; CBCharacteristicPropertyWrite)&#123; /* 最好一个type参数可以为CBCharacteristicWriteWithResponse或type:CBCharacteristicWriteWithResponse,区别是是否会有反馈 */ [peripheral writeValue:value forCharacteristic:characteristic type:CBCharacteristicWriteWithResponse]; &#125;else&#123; NSLog(@"该字段不可写！"); &#125; &#125; 订阅Characteristic的通知1234567891011121314//设置通知-(void)notifyCharacteristic:(CBPeripheral *)peripheral characteristic:(CBCharacteristic *)characteristic&#123; //设置通知，数据通知会进入：didUpdateValueForCharacteristic方法 [peripheral setNotifyValue:YES forCharacteristic:characteristic]; &#125;//取消通知-(void)cancelNotifyCharacteristic:(CBPeripheral *)peripheral characteristic:(CBCharacteristic *)characteristic&#123; [peripheral setNotifyValue:NO forCharacteristic:characteristic];&#125; 停止扫描并断开连接12345678//停止扫描并断开连接-(void)disconnectPeripheral:(CBCentralManager *)centralManager peripheral:(CBPeripheral *)peripheral&#123; //停止扫描 [centralM stopScan]; //断开连接 [centralM cancelPeripheralConnection:peripheral];&#125; 程序运行流程图如下: 参考文章:Kenshin CuiImJackXuliuyanweiCore Bluetooth Programing Guide]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS蓝牙开发(一)]]></title>
      <url>%2F2017%2F04%2F24%2FiOS%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91-%E4%B8%80%2F</url>
      <content type="text"><![CDATA[蓝牙4.0的低能耗，使得蓝牙的应用越来越广泛，穿戴设备、智能家居等都有所涉及。本文主要介绍蓝牙开发相关基础知识，内容主要来自于Apple官方开发文档。 中心模式和外设模式 CoreBluetooth框架用于蓝牙开发，其核心其实是centeral和peripheral，可理解为中心模式和外设模式。 中心模式，就是以你的设备为中心，连接其他的外围设备；外设模式，是使你的设备被其他中心设备连接。蓝牙应用是基于传统的客户端-服务器结构，外围设备有其他设备需要的数据，中心设备使用外围设备提供的数据执行一系列任务。 中心设备搜索和连接正在广告的外围设备外围设备对外广播广告包形式的数据，广告包含了外设的名字，功能服务。另一方面，中心设备可以扫描和监听正在广播广告的外设。 外围设备的数据结构外围设备包含一个或多个服务(services)以及提供了连接信号的强度。一个服务是一些数据的集合，是设备完成一个特定行为的功能。例如，一个心率计的服务是从心率传感器读取数据。服务由特征（characteristics）组成。一个特征提供外围设备服务的更详细信息。例如，心率服务只是说明它包含一个描述心率传感器所在的身体部位的特征和一个传输心率测量数据的特征。 中心设备检测外围设备并与其进行数据交互一个中心设备与一个外围设备连接成功后，便可以搜索外围设备提供的所有服务和特征。（广告的数据可能只含有一部分可用服务）。一个中心设备也可以通过读和写服务的特征来与外围设备交互。例如，你的app可以从数码温度调节器请求当前房间的温度，或者可以提供一个值来设置房间温度。 中心设备、外围设备和外围设备数据的表现形式主要的蓝牙参与者和相关数据对应Core Bluetooth framework中的哪些对象？ 中心设备 1.本地中心设备和远程外围设备 在中心设备这边，一个本地中心设备用一个CBCentralManager对象来代表，这些对象用来管理发现和连接远程设备（用CBPeripheral对象来代表），包括搜索、发现、连接正在广告的外围设备。如下图，显示本地中心设备和远程外围设备在Core Bluetooth framework的表现形式。 2.远程外围设备数据用CBService 和 CBCharacteristic来表示 当你与外围设备（ CBPeripheral对象）进行数据交互，你需要处理它的服务（services）和特征（characteristics），在Core Bluetooth framework中，外围设备的服务用CBService对象来表示。同样的，外围设备的特征用 CBCharacteristic对象来表示 外围设备对应的对象 从OS X10.9 和iOS6开始，Mac和iOS设备可以作为蓝牙4.0的外围设备，为其它设备提供数据，包括其它的Mac、iPhone和iPad设备。当你将你的设备设置为外围设备角色，你需要实现外围设备的一些处理。 1.本地外围设备和外部中心设备 在外围设备这一边，本地外围设备用 CBPeripheralManager对象来表示，这些对象用来管理外围设备数据库中的服务和特征，以及给外部的中心设备（CBCentral对象）广播这些服务，外围设备管理对象同时可以回应远程设备的读和写请求，下图显示本地外围设备和远程中心设备在 Core Bluetooth framework的表示 2.本地外围设备的数据使用CBMutableService 和CBMutableCharacteristic对象来表示 当你设置本地外围设备（ CBPeripheralManager对象）并且进行数据交互，你需要处理它的服务和特征。在Core Bluetooth framework中，本地外围设备的服务用CBMutableService对象来表示。同样的，一个服务的特征用CBMutableCharacteristic对象来表示，图1-7便是本地外围设备的服务和特征的基本结构]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F04%2F14%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Init1$ hexo init More info: Setup Create a new page1$ hexo new page about More info: Page Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Hexo Theme Installation Get it from GitHub 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next Add it to _config.yml 1theme: next Tags Page Add a tags page contains all tags in your site. Create a page name tags 1hexo new page "tags" Edit tags page, set page type to tags 123title: All tagsdate: 2017-04-24 16:01:05type: tags Add tags to theme _config.yml 1234menu: home: / archives: /archives tags: /tags Categories page Add a categories page contains all categories in your site Create a page named categories 1hexo new page "categories" Edit categories page, set page type to categories 123title: All categoriesdate: 2017-04-24 16:02:15type: "categories" Add categories to theme _config.yml 1234menu: home: / archives: /archives categories: /categories Social Media NexT can automatically add links to your Social Media accounts: 123456social: GitHub: your-github-url Twitter: your-twitter-url Weibo: your-weibo-url DouBan: your-douban-url ZhiHu: your-zhihu-url More info: NexT]]></content>
    </entry>

    
  
  
</search>
